version: "3.8"

services:
  kafka:
    image: bitnami/kafka:latest
    container_name: kafka
    networks:
      - app_network
    environment:
      # Random-ish cluster ID for Kraft mode (no Zookeeper)
      - KAFKA_KRAFT_CLUSTER_ID=clJdQ1lJRzFhNzExbGF2
      - KAFKA_CFG_NODE_ID=0
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      # Kafka internal wiring â€“ says who the controller is
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093
      # Listener definitions: internal + external
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093,EXTERNAL://:9094
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092,EXTERNAL://localhost:9094
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,EXTERNAL:PLAINTEXT,PLAINTEXT:PLAINTEXT
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
    healthcheck:
      # Wait until kafka is actually responsive
      test:
        [
          "CMD",
          "kafka-topics.sh",
          "--bootstrap-server",
          "localhost:9092",
          "--list",
        ]
      interval: 10s
      timeout: 10s
      retries: 10
      start_period: 20s

  server_a:
    build:
      context: ./backend/server_a
      dockerfile: Dockerfile
    container_name: server_a
    depends_on:
      kafka:
        condition: service_healthy # only start when kafka is ready
    networks:
      - app_network
    environment:
      - NODE_ENV=production
      - KAFKA_BROKER=kafka:9092 # talks to kafka via internal name

  server_b:
    build:
      context: ./backend/server_b
      dockerfile: Dockerfile
    container_name: server_b
    ports:
      - 3001:3001
    depends_on:
      kafka:
        condition: service_healthy
    networks:
      - app_network
    environment:
      - NODE_ENV=production
      - KAFKA_BROKER=kafka:9092
      - PORT=3001
      - ADMIN_USERNAME=${ADMIN_USERNAME}
      - ADMIN_PASSWORD=${ADMIN_PASSWORD}
      - TOKEN_SECRET=${TOKEN_SECRET}

  emote_generator:
    build: ./backend/emotegen
    container_name: emote_generator
    depends_on:
      kafka:
        condition: service_healthy
    networks:
      - app_network
    environment:
      - KAFKA_BROKER=kafka:9092

  frontend:
    build: ./frontend
    container_name: frontend
    ports:
      - "80:80" # exposed to host, open in browser with http://localhost
    depends_on:
      - server_a # wait until server_a is up
    networks:
      - app_network
    environment:
      - REACT_APP_WS_URL=server_a:8080

networks:
  app_network:
    driver: bridge # standard Docker bridge network
